---
title: "CryptoHack Diffie-Hellman Starter Challenges Writeup"
date: 2025-08-13 00:00:00 +0800
categories: [Cryptography, CryptoHack]
tags: [diffiehellman, ctf, crypto, writeup]
---

## üìú Introduction

The **Diffie-Hellman Starter** section is designed for beginners to understand the mathematical foundations of the Diffie-Hellman key exchange.  
It covers working with finite fields, identifying group generators, computing public values, deriving shared secrets, and converting them into symmetric keys.  
These challenges introduce the essential building blocks of secure key exchange protocols.

---

## üîπ Challenge 1 ‚Äì Working with Fields
### Description
![Desciption](/assets/img/2025-08-13_17-58.png)



### Solution

The number `d` is the multiplicative inverse of `g = 209` modulo `p = 991`.  
The simplest way to compute this in Python is with the built-in `pow()` function:

```python
p = 991
g = 209
d = pow(g, -1, p)
print(d)  # 569
```
Answer: 569

Alternatively, for a deeper understanding, you can find the inverse using the Extended Euclidean Algorithm:

[https://extendedeuclideanalgorithm.com/multiplicative_inverse.php](https://extendedeuclideanalgorithm.com/multiplicative_inverse.php).

## üîπ Challenge 2 ‚Äì Generators of Groups
### Description

![Desciption](/assets/img/2025-08-13_18-03.png)

### Solution

Instead of brute-forcing blindly, we can use Lagrange‚Äôs Theorem, which states that the order of any element must divide the group order.
For a finite field ùîΩ‚Çö*, the group order is always p - 1.

My approach:

    Find all divisors of p - 1.

    Take the second largest divisor as a check order (largest is p - 1 itself).

    Test each candidate number ‚Äî if pow(num, second_largest, p) == 1, it‚Äôs not a generator; otherwise, it is.

```python
p = 28151
possible_orders = [i for i in range(1, p) if (p - 1) % i == 0]
second_largest_order = possible_orders[-2]

for num in range(2, p - 1):
    if pow(num, second_largest_order, p) == 1:
        continue
    else:
        print(num)
        break
```
Answer: 7

## üîπ Challenge 3 ‚Äì Computing Public Values

### Description
![Desciption](/assets/img/2025-08-13_18-05.png)

### Solution

The pow() function in Python is ideal here because it performs modular exponentiation efficiently, even for very large numbers:
```python
g = 2
p = 2410312426921032588552076022197566074856950548502459942654116941958108831682612228890093858261341614673227141477904012196503648957050582631942730706805009223062734745341073406696246014589361659774041027169249453200378729434170325843778659198143763193776859869524088940195577346119843545301547043747207749969763750084308926339295559968882457872412993810129130294592999947926365264059284647209730384947211681434464714438488520940127459844288859336526896320919633919
a = 972107443837033796245864316200458246846904598488981605856765890478853088246897345487328491037710219222038930943365848626194109830309179393018216763327572120124760140018038673999837643377590434413866611132403979547150659053897355593394492586978400044375465657296027592948349589216415363722668361328689588996541370097559090335137676411595949335857341797148926151694299575970292809805314431447043469447485957669949989090202320234337890323293401862304986599884732815

K_pub = pow(g, a, p)
print(K_pub)
```
Answer:

    1806857697840726523322586721820911358489420128129248078673933653533930681676181753849411715714173604352323556558783759252661061186320274214883104886050164368129191719707402291577330485499513522368289395359523901406138025022522412429238971591272160519144672389532393673832265070057319485399793101182682177465364396277424717543434017666343807276970864475830391776403957550678362368319776566025118492062196941451265638054400177248572271342548616103967411990437357924


## üîπ Challenge 4 ‚Äì Computing Shared Secrets

### Description
Now it's time to calculate a shared secret using data received from your friend Alice. Like before, we will be using the NIST parameters:

    g: 2
    p: 2410312426921032588552076022197566074856950548502459942654116941958108831682612228890093858261341614673227141477904012196503648957050582631942730706805009223062734745341073406696246014589361659774041027169249453200378729434170325843778659198143763193776859869524088940195577346119843545301547043747207749969763750084308926339295559968882457872412993810129130294592999947926365264059284647209730384947211681434464714438488520940127459844288859336526896320919633919 

You have received the following integer from Alice:

    A: 70249943217595468278554541264975482909289174351516133994495821400710625291840101960595720462672604202133493023241393916394629829526272643847352371534839862030410331485087487331809285533195024369287293217083414424096866925845838641840923193480821332056735592483730921055532222505605661664236182285229504265881752580410194731633895345823963910901731715743835775619780738974844840425579683385344491015955892106904647602049559477279345982530488299847663103078045601

You generate your secret integer b and calculate your public value B=g^b mod‚Äâp, which you send to Alice.

    b: 12019233252903990344598522535774963020395770409445296724034378433497976840167805970589960962221948290951873387728102115996831454482299243226839490999713763440412177965861508773420532266484619126710566414914227560103715336696193210379850575047730388378348266180934946139100479831339835896583443691529372703954589071507717917136906770122077739814262298488662138085608736103418601750861698417340264213867753834679359191427098195887112064503104510489610448294420720
    B: 518386956790041579928056815914221837599234551655144585133414727838977145777213383018096662516814302583841858901021822273505120728451788412967971809038854090670743265187138208169355155411883063541881209288967735684152473260687799664130956969450297407027926009182761627800181901721840557870828019840218548188487260441829333603432714023447029942863076979487889569452186257333512355724725941390498966546682790608125613166744820307691068563387354936732643569654017172 

![Desciption](/assets/img/2025-08-13_18-46.png)

### Solution

Given the public parameters { g, p, A, B } and Bob‚Äôs private key b, the shared secret K_AB can be computed as:

- **From Bob‚Äôs perspective:** K_AB = A^b mod p
- **From Alice‚Äôs perspective:** K_AB = B^a mod p

where a is Alice‚Äôs private key and b is Bob‚Äôs.

```python
g = 2
p = 2410312426921032588552076022197566074856950548502459942654116941958108831682612228890093858261341614673227141477904012196503648957050582631942730706805009223062734745341073406696246014589361659774041027169249453200378729434170325843778659198143763193776859869524088940195577346119843545301547043747207749969763750084308926339295559968882457872412993810129130294592999947926365264059284647209730384947211681434464714438488520940127459844288859336526896320919633919

A = 70249943217595468278554541264975482909289174351516133994495821400710625291840101960595720462672604202133493023241393916394629829526272643847352371534839862030410331485087487331809285533195024369287293217083414424096866925845838641840923193480821332056735592483730921055532222505605661664236182285229504265881752580410194731633895345823963910901731715743835775619780738974844840425579683385344491015955892106904647602049559477279345982530488299847663103078045601

b = 12019233252903990344598522535774963020395770409445296724034378433497976840167805970589960962221948290951873387728102115996831454482299243226839490999713763440412177965861508773420532266484619126710566414914227560103715336696193210379850575047730388378348266180934946139100479831339835896583443691529372703954589071507717917136906770122077739814262298488662138085608736103418601750861698417340264213867753834679359191427098195887112064503104510489610448294420720
B = 518386956790041579928056815914221837599234551655144585133414727838977145777213383018096662516814302583841858901021822273505120728451788412967971809038854090670743265187138208169355155411883063541881209288967735684152473260687799664130956969450297407027926009182761627800181901721840557870828019840218548188487260441829333603432714023447029942863076979487889569452186257333512355724725941390498966546682790608125613166744820307691068563387354936732643569654017172

shared_secret = pow(A, b, p)
print(shared_secret)
```
Solution:

    1174130740413820656533832746034841985877302086316388380165984436672307692443711310285014138545204369495478725102882673427892104539120952393788961051992901649694063179853598311473820341215879965343136351436410522850717408445802043003164658348006577408558693502220285700893404674592567626297571222027902631157072143330043118418467094237965591198440803970726604537807146703763571606861448354607502654664700390453794493176794678917352634029713320615865940720837909466


## üîπ Challenge 5 ‚Äì Deriving Symmetric Keys
### Description
Alice wants to send you her secret flag and asks you to generate a shared secret with her. She also tells you she will be using the NIST standard:

    g: 2
    p: 2410312426921032588552076022197566074856950548502459942654116941958108831682612228890093858261341614673227141477904012196503648957050582631942730706805009223062734745341073406696246014589361659774041027169249453200378729434170325843778659198143763193776859869524088940195577346119843545301547043747207749969763750084308926339295559968882457872412993810129130294592999947926365264059284647209730384947211681434464714438488520940127459844288859336526896320919633919 

You receive the following integer from Alice:

    A: 112218739139542908880564359534373424013016249772931962692237907571990334483528877513809272625610512061159061737608547288558662879685086684299624481742865016924065000555267977830144740364467977206555914781236397216033805882207640219686011643468275165718132888489024688846101943642459655423609111976363316080620471928236879737944217503462265615774774318986375878440978819238346077908864116156831874695817477772477121232820827728424890845769152726027520772901423784 

You then generate your secret integer and calculate your public one, which you send to Alice.

    b: 197395083814907028991785772714920885908249341925650951555219049411298436217190605190824934787336279228785809783531814507661385111220639329358048196339626065676869119737979175531770768861808581110311903548567424039264485661330995221907803300824165469977099494284722831845653985392791480264712091293580274947132480402319812110462641143884577706335859190668240694680261160210609506891842793868297672619625924001403035676872189455767944077542198064499486164431451944
    B: 1241972460522075344783337556660700537760331108332735677863862813666578639518899293226399921252049655031563612905395145236854443334774555982204857895716383215705498970395379526698761468932147200650513626028263449605755661189525521343142979265044068409405667549241125597387173006460145379759986272191990675988873894208956851773331039747840312455221354589910726982819203421992729738296452820365553759182547255998984882158393688119629609067647494762616719047466973581

Individually you each use the shared secret to derive an AES private key. This allows you to encrypt large amounts of data over your channel without needing to exchange keys again.

Alice sends you the following IV and ciphertext:

    {'iv': '737561146ff8194f45290f5766ed6aba', 'encrypted_flag': '39c99bf2f0c14678d6a5416faef954b5893c316fc3c48622ba1fd6a9fe85f3dc72a29c394cf4bc8aff6a7b21cae8e12c'} 

Decrypt this to obtain your flag!
### Solution

In this challenge, we are given the public Diffie‚ÄìHellman parameters `{ g, p, A, B }`, Bob‚Äôs private key `b`, and the ciphertext with its IV.  

The goal is to compute the shared secret `K_AB` from Bob‚Äôs perspective:

K_AB = A^b mod p

Once the shared secret is derived, it is used to generate the AES key:

1. Convert the shared secret to a string and encode it as ASCII.
2. Hash it using **SHA-1**.
3. Take the first 16 bytes of the digest as the AES key.

The flag is encrypted using **AES in CBC mode**, with the IV provided in hexadecimal format.  
After computing the key, we decrypt the ciphertext using the provided IV and remove PKCS#7 padding to obtain the plaintext flag.

The challenge provides a helper script `decrypt.py` that already implements:
- AES decryption in CBC mode
- SHA-1‚Äìbased key derivation
- PKCS#7 padding check and removal

**Steps to solve:**
1. Copy the given public parameters, Alice‚Äôs public key, and Bob‚Äôs private key into the script.
2. Compute the shared secret using Python‚Äôs built-in `pow()` function with three arguments for modular exponentiation.
3. Call the `decrypt_flag()` function with the computed secret, IV, and ciphertext.

Running the script will output the decrypted flag.

```python
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
import hashlib


def is_pkcs7_padded(message):
    padding = message[-message[-1]:]
    return all(padding[i] == len(padding) for i in range(0, len(padding)))


def decrypt_flag(shared_secret: int, iv: str, ciphertext: str):
    # Derive AES key from shared secret
    sha1 = hashlib.sha1()
    sha1.update(str(shared_secret).encode('ascii'))
    key = sha1.digest()[:16]
    # Decrypt flag
    ciphertext = bytes.fromhex(ciphertext)
    iv = bytes.fromhex(iv)
    cipher = AES.new(key, AES.MODE_CBC, iv)
    plaintext = cipher.decrypt(ciphertext)

    if is_pkcs7_padded(plaintext):
        return unpad(plaintext, 16).decode('ascii')
    else:
        return plaintext.decode('ascii')


g = 2
p = 2410312426921032588552076022197566074856950548502459942654116941958108831682612228890093858261341614673227141477904012196503648957050582631942730706805009223062734745341073406696246014589361659774041027169249453200378729434170325843778659198143763193776859869524088940195577346119843545301547043747207749969763750084308926339295559968882457872412993810129130294592999947926365264059284647209730384947211681434464714438488520940127459844288859336526896320919633919

A = 112218739139542908880564359534373424013016249772931962692237907571990334483528877513809272625610512061159061737608547288558662879685086684299624481742865016924065000555267977830144740364467977206555914781236397216033805882207640219686011643468275165718132888489024688846101943642459655423609111976363316080620471928236879737944217503462265615774774318986375878440978819238346077908864116156831874695817477772477121232820827728424890845769152726027520772901423784

b = 197395083814907028991785772714920885908249341925650951555219049411298436217190605190824934787336279228785809783531814507661385111220639329358048196339626065676869119737979175531770768861808581110311903548567424039264485661330995221907803300824165469977099494284722831845653985392791480264712091293580274947132480402319812110462641143884577706335859190668240694680261160210609506891842793868297672619625924001403035676872189455767944077542198064499486164431451944
B = 1241972460522075344783337556660700537760331108332735677863862813666578639518899293226399921252049655031563612905395145236854443334774555982204857895716383215705498970395379526698761468932147200650513626028263449605755661189525521343142979265044068409405667549241125597387173006460145379759986272191990675988873894208956851773331039747840312455221354589910726982819203421992729738296452820365553759182547255998984882158393688119629609067647494762616719047466973581


shared_secret = pow(A,b,p)
iv = "737561146ff8194f45290f5766ed6aba"
ciphertext = "39c99bf2f0c14678d6a5416faef954b5893c316fc3c48622ba1fd6a9fe85f3dc72a29c394cf4bc8aff6a7b21cae8e12c"

print(decrypt_flag(shared_secret, iv, ciphertext))

```

Solution:

    crypto{sh4r1ng_s3cret5_w1th_fr13nd5}